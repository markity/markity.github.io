<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>知识分享-线程, 协程以及网络模型 | Markity&#39;s Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="Markity">
  
  
    <meta name="description" content="本文目的聚焦线程, 协程, 有栈协程, 无栈协程, reactor, 网络框架, netpoll, 阻塞等名词, 了解比较主流的网络编程逻辑。
背景多核时代, 使用多线程能加速运算。然而网络&amp;#x2F;磁盘io的阻塞会白白浪费时间, 浪费线程资源。但是线程资源是宝贵的, 开多了浪费性能(切换会耗费很多时间), 开少了无法利用多核的优势, 因此有多少核开多少个线程是主流认知。
然而阻塞的io会让线程">
  
  <meta name="description" content="本文目的聚焦线程, 协程, 有栈协程, 无栈协程, reactor, 网络框架, netpoll, 阻塞等名词, 了解比较主流的网络编程逻辑。 背景多核时代, 使用多线程能加速运算。然而网络&#x2F;磁盘io的阻塞会白白浪费时间, 浪费线程资源。但是线程资源是宝贵的, 开多了浪费性能(切换会耗费很多时间), 开少了无法利用多核的优势, 因此有多少核开多少个线程是主流认知。 然而阻塞的io会让线程">
<meta property="og:type" content="article">
<meta property="og:title" content="知识分享-线程, 协程以及网络模型">
<meta property="og:url" content="http://example.com/2023/10/09/share1/index.html">
<meta property="og:site_name" content="Markity&#39;s Notes">
<meta property="og:description" content="本文目的聚焦线程, 协程, 有栈协程, 无栈协程, reactor, 网络框架, netpoll, 阻塞等名词, 了解比较主流的网络编程逻辑。 背景多核时代, 使用多线程能加速运算。然而网络&#x2F;磁盘io的阻塞会白白浪费时间, 浪费线程资源。但是线程资源是宝贵的, 开多了浪费性能(切换会耗费很多时间), 开少了无法利用多核的优势, 因此有多少核开多少个线程是主流认知。 然而阻塞的io会让线程">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-10-09T14:17:55.000Z">
<meta property="article:modified_time" content="2023-10-21T09:48:08.723Z">
<meta property="article:author" content="Markity">
<meta property="article:tag" content="知识分享">
<meta property="article:tag" content="网络模型">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Markity&#39;s Notes" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="https://blog-image-1257452121.cos.ap-chongqing.myqcloud.com/avatar.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Markity&#39;s Notes</a></h1>
    <p><a href="/"></a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2023/10/09/share1/">
  <time datetime="2023-10-09T14:17:55.000Z">
    2023-10-09
  </time>
</a>
    
    
  
    <h1 class="title">知识分享-线程, 协程以及网络模型</h1>
  

  </header>
  
  <div class="entry">
    
      <h3 id="本文目的"><a href="#本文目的" class="headerlink" title="本文目的"></a>本文目的</h3><p>聚焦线程, 协程, 有栈协程, 无栈协程, reactor, 网络框架, netpoll, 阻塞等名词, 了解比较主流的网络编程逻辑。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>多核时代, 使用多线程能加速运算。然而网络&#x2F;磁盘io的阻塞会白白浪费时间, 浪费线程资源。但是线程资源是宝贵的, 开多了浪费性能(切换会耗费很多时间), 开少了无法利用多核的优势, 因此有多少核开多少个线程是主流认知。</p>
<p>然而阻塞的io会让线程浪费掉cpu时间, 所以linux推出了非阻塞的io, 通过<code>O_NONBLOCK</code>打开的文件描述符读写都不会阻塞, 配合epoll可以实现单线程处理海量io。</p>
<h3 id="传统reactor"><a href="#传统reactor" class="headerlink" title="传统reactor"></a>传统reactor</h3><p>目前新语言陆续推出协程, 配套的网络设施也发生了大量变化。例如在”线程资源”稀缺的传统语言中(java和cpp的低版本), epoll(或其它的多路复用系统调用)实现的reactor事件回调模型是主流。我不了解proactor, 所以不讨论它。</p>
<span id="more"></span>

<p>在没有协程的传统语言中, 为了尽量减少系统调度的频率, 用少量线程+epoll处理海量连接是高并发服务器的基本思路。陈硕提到, 一个好的reactor框架会减少程序员遇到的”偶发复杂性”(意思就是说不用自己手写epoll), 让程序员更加专注于业务。</p>
<p>陈硕说的好, 那我就不用epoll开搞了, 而是直接聚焦传统语言最常用的reactor模型写个简单的demo。c++比较好的reactor框架可能是muduo, libhv(字节的大佬做的, 我没用过), java的则是netty(据说很多开源轮子都用它做网络)。笔者对muduo比较熟悉, 这里抄一段代码来做演示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;muduo/base/Logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;muduo/net/EventLoop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;muduo/net/TcpServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;muduo/net/TcpConnection.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    muduo::net::EventLoop loop;</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">listenAddr</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span></span>;</span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;loop, listenAddr, <span class="string">&quot;My Echo Server&quot;</span>, muduo::net::TcpServer::Option::kReusePort)</span></span>;</span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>([](<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn)&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;一个新连接的到来&quot;</span>;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(<span class="string">&quot;你好新连接\n&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>([](<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buf, muduo::Timestamp)&#123;</span><br><span class="line">        std::string <span class="built_in">msg</span>(buf-&gt;<span class="built_in">retrieveAllAsString</span>());</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;收到一条消息&quot;</span> &lt;&lt; msg.<span class="built_in">size</span>();</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实写reactor就是在写回调, 注意回调里面不能有阻塞的代码, 如果要每隔两秒打印一条信息, 必须注册定时器回调(而不是sleep, sleep会使这个线程停止调度, 是极其错误的)。任何阻塞线程的操作(甚至是耗时的计算操作, 极端点, 查询本地数据库也都是)都不应该出现在回调代码中。</p>
<p>在这样的编程模型下, 如果要为每个连接提供服务, 则需要用内存保存每个连接的当前状态做一个状态机(其实也可以用数据库嘛, 不过reactor的精髓就是不要在回调里进行耗时操作, 所以用数据库不好)。</p>
<p>reactor的优点是做一些复杂的业务写状态机, 控制力极强, 如果用全局变量存储每个连接的上下文, 在回调代码里锁都不用加就能随便访问所有连接的上下文, 也可以向每个连接发送消息。</p>
<p>reactor的缺点也很明显, 那就是回调会割裂逻辑, 每次回调都需要查找当前连接的状态以确定下一步该干啥, 我认为用reactor写业务其实就做状态机。</p>
<p>举个简单的例子, 我这里有个counter服务, 服务器为每一个连接维护一个计数器, 用户每次发一个记数请求分包, 服务器就把它的计数器加1并且返回。那么就需要为这个连接开辟一块内存, 存储当前值, 每次message回调先解析请求包, 确认是计数请求后, 就访问对应的内存, 递增counter并返回。在这个简单的场景下, counter保存的就是连接的状态。针对这个场景, 我们给一个伪代码, 说明这个简单的”状态机”:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了给每个连接给一个id, 用一个全局变量</span></span><br><span class="line"><span class="type">int</span> globalConnID = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">onConnection</span>(conn) &#123;</span><br><span class="line">    <span class="type">int</span> connID = globalConnID++</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开辟一块内存, 我这里用new来表示它被分配在堆内存上</span></span><br><span class="line">    connCtx = <span class="keyword">new</span> ConnContext&#123;</span><br><span class="line">        ConnID: connID</span><br><span class="line">        Counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 每个连接都有一个槽给程序员放东西, 想用就用, 其实一般人拿来放连接的上下文信息</span></span><br><span class="line">	<span class="comment">//		这就像gin的Set/Get一样, 也给每个请求维护一个槽, 一个意思嘛</span></span><br><span class="line">    conn.<span class="built_in">setContext</span>(connCtx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用4字节包头+包体的分包协议</span></span><br><span class="line"><span class="built_in">onMessage</span>(conn, buf, timestamp) &#123;</span><br><span class="line">    <span class="comment">// 连四字节包头都还没有</span></span><br><span class="line">    <span class="keyword">if</span> (buf.readableBytes &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包体还没收全</span></span><br><span class="line">    bodySize = buf.<span class="built_in">peekInt64</span>();</span><br><span class="line">    <span class="keyword">if</span> (buf.readableBytes &lt; bodySize + <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 丢弃包头的四个字节</span></span><br><span class="line">    buf.<span class="built_in">retrieve</span>(<span class="number">4</span>)</span><br><span class="line">    bodyBytes = buf.<span class="built_in">retrieveAsString</span>(bodySize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unmarshal请求包</span></span><br><span class="line">    var myRequest Request</span><br><span class="line">    <span class="built_in">unmarshal</span>(bodyBytes, &amp;myRequest)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myRequest.reqType == <span class="string">&quot;counter&quot;</span>) &#123;</span><br><span class="line">        c = ctx.getContext.Counter;</span><br><span class="line">        <span class="comment">// 下面省略一系列封包的代码, 需要把数据打包成 4字节包大小前缀+包体的形式</span></span><br><span class="line">        <span class="comment">// 然后调用send把消息给reactor模型发送</span></span><br><span class="line">        <span class="comment">// conn.send(......)</span></span><br><span class="line">        ctx.getContext.Counter++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然reactor模型写代码很繁琐, 却能提供高并发和很强的控制力(单个reactor下能在一个eventloop里面操作所有连接)。陈硕认为reactor框架的控制力和适用场景比proactor好, 主要是写代码更简单, proactor的性能虽然好, 但是写代码却超级复杂。</p>
<p>eventloop是什么? 这是reactor最基本的组件, 中文名字叫事件循环, 跑eventloop的线程被成为io线程, 它会执行epoll操作。如果有事件发生就触发我们写好的回调, 所以我们的回调是被eventloop所处的线程直接调用的, 不能在回调中写耗时操作, 不然就耽误了epoll, 胜任不了高并发的任务了。下面我展示一个基本的事件循环应该有的东西, 见我演示。</p>
<p>考虑一个复杂的聊天协议, 一个用户发送广播包, 需要把消息转发给所有连接。如果用go写, 那么一般是一个goroutine负责一个连接, 要做消息的广播其实很复杂。但是如果用reactor来写, 自己只需要维持所有连接的上下文, 就能不加锁地操作所有连接, 其实是相当舒适的, 这也是我说reactor控制力强的原因。</p>
<p>绝对不要在回调里面进行任何耗时操作(我们把跑eventloop的线程叫做io线程)，即使是打开读写文件也要考虑再三, 如果读写文件确实耗时, 那么就放弃在io线程进行。那么如果确实要进行耗时操作怎么办呢? 正确的做法是把cpu密集的耗时操作通过队列丢给工作线程, 然后再把运算结果”打回”io线程让io把执行结果发送给用户。为什么java面试强调用线程池? 因为很多人会写netty代码, 那么线程池就是标配, 程序员必须了解。</p>
<p>此外, 操作数据库的时候, 如果轮子只提供了阻塞的函数, 那么也可以开一个数据库线程, io线程把查询任务丢给数据库线程, 数据库线程执行完&#x2F;拿到响应后再告知io线程执行结果。实际上很多程序也是这么做的, 提供n个线程跑reactor, 一个线程做异步日志, 一个线程做数据库线程……</p>
<p>reactor框架提供了runInLoop的方法, 能够从其它线程把代码”打入”io线程进行执行。一般而言, 我倾向于只让io线程读写连接的上下文, 不暴露给其它线程, 这样可以避免加锁, 控制力极强。</p>
<p>为什么java的程序员强调线程池, go的程序员却根本不care? 那是因为对于java的好多业务框架都是基于reactor回调的, 谁能容忍在io线程的回调里写耗时代码呢? 这种情况把耗时任务分发给线程池才是对的。</p>
<h3 id="多reactor模型的优势与代价"><a href="#多reactor模型的优势与代价" class="headerlink" title="多reactor模型的优势与代价"></a>多reactor模型的优势与代价</h3><p>简单而言, 我上面提到的例子只利用了一个线程, 是一个单reactor的例子, 虽然只用了一个线程, 但是能通过状态机+回调的方式处理大量连接, 这就是reactor(或者说epoll)的魅力。</p>
<p>利用起一个线程远远不够, io线程就算是io密集的, 也会伴随大量的拷贝操作, 那么利用多个线程就自然能加速拷贝操作, 降低整体延迟。很多场景下其实单reactor是极其合适的, 比如redis, 这种单reactor的模式控制力极强。我没有背过八股, 我认为redis用单reactor的原因是它的并发并不是那么大, 拷贝操作也不是很耗时(就是io线程编码解码很简单, 耗时很短), 单reactor完全能胜任。</p>
<p>多reactor的主流模式是: 一个线程一直accept新的连接, 然后递交给不同线程的reactor eventloop, 把连接均匀的分给不同的线程处理。</p>
<p>虽然多reactor能降低延迟, 提供均质的服务, 但是有得必有失。我个人很喜欢单reactor, 原因是状态信息都仅仅被io线程独享, 如果要做聊天这样的场景, 那么单reactor将没有任何加锁成本, 直接查表send就能实现广播聊天。</p>
<p>使用多reactor有个弊端, 业务如果涉及多个连接的广播就很麻烦。如果连接被分散给多个线程, 那么每个线程都维护自己的连接的状态, 中间要进行信息交互, 必然会需要一些机制, 这中间必然有额外的同步开销。</p>
<p>在多reactor下的对于聊天的这种广播场景, 我能想到的一个方法就是每个eventloop都保存其它eventloop的引用, 当一个连接发送消息时, 直接挨个对其它eventloop进行runInLoop, 其他的eventloop也能收到这个广播信息咯。</p>
<h3 id="有栈协程和线程"><a href="#有栈协程和线程" class="headerlink" title="有栈协程和线程"></a>有栈协程和线程</h3><p>go用的io都是阻塞的, goroutine给人一种在用线程的感觉。然而并不是每个goroutine都享有一个线程, 魔法在于go的io是自己用epoll实现的, 每个看起来会阻塞的操作都被golang重新封装, 而绝对不使用操作系统会阻塞的io, 例如go绝对不会调用nanosleep(2)。</p>
<p>java23的虚拟线程只感觉自己好像突然能无限开线程执行阻塞的网络操作也不会出问题了, 这种协程的好处是程序员对此无感, 只觉得自己在写线程。</p>
<p>go的程序员一般写网络代码就是一个goroutine循环accept, 然后直接开goroutine操作这个连接, 更离谱的是, 甚至对于一个连接, 读写都单独开goroutine。通常一个连接可以有读&#x2F;写&#x2F;心跳三个goroutine处理。</p>
<p>go通常情况下会开一定数量的系统线程来跑协程, 但是实际运行过程中线程数目有时候会变多, 接下来我将通过一个问题说明原因:</p>
<p>如何避免真正进行系统调用时阻塞线程? 例如go提供了syscall, 我们用<code>syscall.Write</code>写入一个将会阻塞的fd, 为毛没有任何副作用, 即使开很多个gorouine让它们阻塞在那里最后go也能正常调度大量goroutine? 我这里说的副作用的意思是, 我知道go底层是一定数量的系统线程调度很多的goroutine代码, 但是我广泛的使用syscall阻塞线程, 也不会耽搁golang调度其它协程。</p>
<p>这是由于在调用系统调用前会新开一个新的线程来执行系统调用, 也就是说<code>syscall.Write</code>直接新开一个线程避免阻塞(即使有的系统调用不会阻塞, go也选择新开线程, 这是一种保险, 也是一种加速手段, 试想一个线程等待磁盘io, 其实是这部分时间线程完全没有用来跑代码, 如果go始终只使用N个线程跑代码, 那么等待磁盘io的时间就被白白浪费了), syscall.XXX在语言层面封装了新开线程的逻辑。</p>
<p>在java中, 虚拟线程(协程)被放在一个容量一定的线程池(和cpu数量有关)里不断调度, 使用java的库尝试进行系统调用时, java也会首先判断这个执行流是不是虚拟线程, 如果是, 就新开一个线程进行系统调用, 防止把那个池子里的线程全搞阻塞住了。</p>
<h3 id="go里的epoll"><a href="#go里的epoll" class="headerlink" title="go里的epoll"></a>go里的epoll</h3><p><code>os.OpenFile</code>在open打开文件时, go语言底部也是使用了<code>O_NONBLOCK</code>的, 虽然go提供给语言用户的网络库看起来是阻塞的, 但是打开的文件描述符其实都是非阻塞的。简单看看代码, 瞅瞅什么情况:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是os.OpenFile的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">	testlog.Open(name)</span><br><span class="line">	f, err := openFileNolog(name, flag, perm) <span class="comment">// 我们来看看这个</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openFileNolog</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个sticky和文件的sticky位有关, sticky是作用给目录的一个特殊的位, linux支持CreateWithStickyBit</span></span><br><span class="line">    <span class="comment">//      所以下面的setSticky没用</span></span><br><span class="line">	<span class="comment">// setSticky := false</span></span><br><span class="line">	<span class="comment">// if !supportsCreateWithStickyBit &amp;&amp; flag&amp;O_CREATE != 0 &amp;&amp; perm&amp;ModeSticky != 0 &#123;</span></span><br><span class="line">	<span class="comment">// 	if _, err := Stat(name); IsNotExist(err) &#123;</span></span><br><span class="line">	<span class="comment">// 		setSticky = true</span></span><br><span class="line">	<span class="comment">// 	&#125;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r <span class="type">int</span></span><br><span class="line">    <span class="comment">// 为毛for循环, 因为打开fuse file system居然可以被信号中断, 这里要无限尝试, 见#11180</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> e <span class="type">error</span></span><br><span class="line">        <span class="comment">// 真正调用syscall.Open</span></span><br><span class="line">		r, e = syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))</span><br><span class="line">		<span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可能会非常不巧地被信号中断, 需要重试</span></span><br><span class="line">		<span class="comment">// We have to check EINTR here, per issues 11180 and 39237.</span></span><br><span class="line">		<span class="keyword">if</span> e == syscall.EINTR &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;Op: <span class="string">&quot;open&quot;</span>, Path: name, Err: e&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 别忘了, linux支持create file的同时设置sticky位, 所以下面是废代码</span></span><br><span class="line">	<span class="comment">// open(2) itself won&#x27;t handle the sticky bit on *BSD and Solaris</span></span><br><span class="line">	<span class="comment">// if setSticky &#123;</span></span><br><span class="line">	<span class="comment">// 	setStickyBit(name)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持create file的时候设置closeOnExec, 所以下面是废代码</span></span><br><span class="line">	<span class="comment">// There&#x27;s a race here with fork/exec, which we are</span></span><br><span class="line">	<span class="comment">// content to live with. See ../syscall/exec_unix.go.</span></span><br><span class="line">	<span class="comment">// if !supportsCloseOnExec &#123;</span></span><br><span class="line">	<span class="comment">// 	syscall.CloseOnExec(r)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续探究newFile</span></span><br><span class="line">	<span class="keyword">return</span> newFile(<span class="type">uintptr</span>(r), name, kindOpenFile), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFile</span><span class="params">(fd <span class="type">uintptr</span>, name <span class="type">string</span>, kind newFileKind)</span></span> *File &#123;</span><br><span class="line">	fdi := <span class="type">int</span>(fd)</span><br><span class="line">	<span class="keyword">if</span> fdi &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 封装成File</span></span><br><span class="line">    <span class="comment">// 注意下面的poll.FD, 俗称PollFD, 是一个很重要的结构, 可以借助它注册文件描述符给netpoll</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    type FD struct &#123;</span></span><br><span class="line"><span class="comment">        // PollFD拥有一个读写锁, 防止读写同时进行, 想象一个*os.File是可以共享的</span></span><br><span class="line"><span class="comment">        //      如果多个执行流同时找netpoll读数据, 那读到的数据必然可能串话</span></span><br><span class="line"><span class="comment">        //      写也是一样的, netpoll的写缓冲不大, 如果写一半再继续写且不加锁, 一个write也将不会是原子的</span></span><br><span class="line"><span class="comment">        //      协程1 write 1111111....11111(很多的1), 协程2 write 222222(很少的2), 可能最后写入的是</span></span><br><span class="line"><span class="comment">        //      1111111...222222....11111, 这就是我说的串话, 所以加读写锁是必要的</span></span><br><span class="line"><span class="comment">        // Lock sysfd and serialize access to Read and Write methods.</span></span><br><span class="line"><span class="comment">        fdmu fdMutex</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // System file descriptor. Immutable until Close.</span></span><br><span class="line"><span class="comment">        Sysfd int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // I/O poller.</span></span><br><span class="line"><span class="comment">        pd pollDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // Writev cache.</span></span><br><span class="line"><span class="comment">        iovecs *[]syscall.Iovec</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // Semaphore signaled when file is closed.</span></span><br><span class="line"><span class="comment">        csema uint32</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // Non-zero if this file has been set to blocking mode.</span></span><br><span class="line"><span class="comment">        isBlocking uint32</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // Whether this is a streaming descriptor, as opposed to a</span></span><br><span class="line"><span class="comment">        // packet-based descriptor like a UDP socket. Immutable.</span></span><br><span class="line"><span class="comment">        IsStream bool</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // Whether a zero byte read indicates EOF. This is false for a</span></span><br><span class="line"><span class="comment">        // message based socket connection.</span></span><br><span class="line"><span class="comment">        ZeroReadIsEOF bool</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // Whether this is a file rather than a network socket.</span></span><br><span class="line"><span class="comment">        isFile bool</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	f := &amp;File&#123;&amp;file&#123;</span><br><span class="line">		pfd: poll.FD&#123;</span><br><span class="line">			Sysfd:         fdi,</span><br><span class="line">			IsStream:      <span class="literal">true</span>,</span><br><span class="line">			ZeroReadIsEOF: <span class="literal">true</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		name:        name,</span><br><span class="line">		stdoutOrErr: fdi == <span class="number">1</span> || fdi == <span class="number">2</span>,</span><br><span class="line">	&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否可以poll, 能poll就注册给netpoll</span></span><br><span class="line">	pollable := kind == kindOpenFile || kind == kindPipe || kind == kindNonBlock</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the caller passed a non-blocking filedes (kindNonBlock),</span></span><br><span class="line">	<span class="comment">// we assume they know what they are doing so we allow it to be</span></span><br><span class="line">	<span class="comment">// used with kqueue.</span></span><br><span class="line">	<span class="keyword">if</span> kind == kindOpenFile &#123;</span><br><span class="line">		<span class="keyword">switch</span> runtime.GOOS &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>, <span class="string">&quot;ios&quot;</span>, <span class="string">&quot;dragonfly&quot;</span>, <span class="string">&quot;freebsd&quot;</span>, <span class="string">&quot;netbsd&quot;</span>, <span class="string">&quot;openbsd&quot;</span>:</span><br><span class="line">			<span class="keyword">var</span> st syscall.Stat_t</span><br><span class="line">			err := ignoringEINTR(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> syscall.Fstat(fdi, &amp;st)</span><br><span class="line">			&#125;)</span><br><span class="line">			typ := st.Mode &amp; syscall.S_IFMT</span><br><span class="line">			<span class="comment">// Don&#x27;t try to use kqueue with regular files on *BSDs.</span></span><br><span class="line">			<span class="comment">// On FreeBSD a regular file is always</span></span><br><span class="line">			<span class="comment">// reported as ready for writing.</span></span><br><span class="line">			<span class="comment">// On Dragonfly, NetBSD and OpenBSD the fd is signaled</span></span><br><span class="line">			<span class="comment">// only once as ready (both read and write).</span></span><br><span class="line">			<span class="comment">// Issue 19093.</span></span><br><span class="line">			<span class="comment">// Also don&#x27;t add directories to the netpoller.</span></span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; (typ == syscall.S_IFREG || typ == syscall.S_IFDIR) &#123;</span><br><span class="line">				pollable = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// In addition to the behavior described above for regular files,</span></span><br><span class="line">			<span class="comment">// on Darwin, kqueue does not work properly with fifos:</span></span><br><span class="line">			<span class="comment">// closing the last writer does not cause a kqueue event</span></span><br><span class="line">			<span class="comment">// for any readers. See issue #24164.</span></span><br><span class="line">			<span class="keyword">if</span> (runtime.GOOS == <span class="string">&quot;darwin&quot;</span> || runtime.GOOS == <span class="string">&quot;ios&quot;</span>) &amp;&amp; typ == syscall.S_IFIFO &#123;</span><br><span class="line">				pollable = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们来研究FD.Init是啥</span></span><br><span class="line">	<span class="keyword">if</span> err := f.pfd.Init(<span class="string">&quot;file&quot;</span>, pollable); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// An error here indicates a failure to register</span></span><br><span class="line">		<span class="comment">// with the netpoll system. That can happen for</span></span><br><span class="line">		<span class="comment">// a file descriptor that is not supported by</span></span><br><span class="line">		<span class="comment">// epoll/kqueue; for example, disk files on</span></span><br><span class="line">		<span class="comment">// Linux systems. We assume that any real error</span></span><br><span class="line">		<span class="comment">// will show up in later I/O.</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> pollable &#123;</span><br><span class="line">		<span class="comment">// We successfully registered with netpoll, so put</span></span><br><span class="line">		<span class="comment">// the file into nonblocking mode.</span></span><br><span class="line">        <span class="comment">// 再次保证文件是NonBlock的</span></span><br><span class="line">		<span class="keyword">if</span> err := syscall.SetNonblock(fdi, <span class="literal">true</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			f.nonblock = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	runtime.SetFinalizer(f.file, (*file).<span class="built_in">close</span>)</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Init(net <span class="type">string</span>, pollable <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 注意下面的英文注释, 就算是socket, 也其实可以当成普通文件的文件描述符对待</span></span><br><span class="line">	<span class="comment">//		linux的抽象就是这么好</span></span><br><span class="line">	<span class="comment">// We don&#x27;t actually care about the various network types.</span></span><br><span class="line">	<span class="keyword">if</span> net == <span class="string">&quot;file&quot;</span> &#123;</span><br><span class="line">		fd.isFile = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !pollable &#123;</span><br><span class="line">		fd.isBlocking = <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	err := fd.pd.init(fd)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// If we could not initialize the runtime poller,</span></span><br><span class="line">		<span class="comment">// assume we are using blocking mode.</span></span><br><span class="line">		fd.isBlocking = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span> &#123;</span><br><span class="line">	serverInit.Do(runtime_pollServerInit)</span><br><span class="line">	<span class="comment">// runtime的代码看不到了</span></span><br><span class="line">	ctx, errno := runtime_pollOpen(<span class="type">uintptr</span>(fd.Sysfd))</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">	&#125;</span><br><span class="line">	pd.runtimeCtx = ctx</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime_pollOpen其实的代码就追溯不到了</span></span><br></pre></td></tr></table></figure>

<p>看情况是<code>os.OpenFile</code>把fd注册给了netpoll, 那么<code>Read</code>, <code>Write</code>会是什么情况?</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err := f.checkValid(<span class="string">&quot;read&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	n, e := f.read(b)</span><br><span class="line">	<span class="keyword">return</span> n, f.wrapErr(<span class="string">&quot;read&quot;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	n, err = f.pfd.Read(b)</span><br><span class="line">	runtime.KeepAlive(f)</span><br><span class="line">	<span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们需要看的就是这个, PollFD的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 加读锁, 防止我之前提到的&quot;串话&quot;</span></span><br><span class="line">	<span class="keyword">if</span> err := fd.readLock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fd.readUnlock()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// If the caller wanted a zero byte read, return immediately</span></span><br><span class="line">		<span class="comment">// without trying (but after acquiring the readLock).</span></span><br><span class="line">		<span class="comment">// Otherwise syscall.Read returns 0, nil which looks like</span></span><br><span class="line">		<span class="comment">// io.EOF.</span></span><br><span class="line">		<span class="comment">// TODO(bradfitz): make it wait for readability? (Issue 15735)</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := fd.pd.prepareRead(fd.isFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fd.IsStream &amp;&amp; <span class="built_in">len</span>(p) &gt; maxRW &#123;</span><br><span class="line">		p = p[:maxRW]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">/* ignoringEINTERIO就是一个小加工具, 看下面的代码</span></span><br><span class="line"><span class="comment">            func ignoringEINTRIO(fn func(fd int, p []byte) (int, error), fd int, p []byte) (int, error) &#123;</span></span><br><span class="line"><span class="comment">                for &#123;</span></span><br><span class="line"><span class="comment">                    n, err := fn(fd, p)</span></span><br><span class="line"><span class="comment">                    if err != syscall.EINTR &#123;</span></span><br><span class="line"><span class="comment">                        return n, err</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            不得不说go在linux下的实现其实可以选择更好的signalfd, 把信号融入事件循环, 不至于每个syscall都来检查一下EINTR</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			n = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 如果fd没有任何数据到来, fild.Read将会返回EAGAIN, n = 0, 那么就waitRead</span></span><br><span class="line">			<span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">				<span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		err = fd.eofError(n, err)</span><br><span class="line">		<span class="keyword">return</span> n, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面来看waitRead, 这是很神奇的东西, netpoll的调度也就体现在这了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> waitRead(isFile <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pd.wait(<span class="string">&#x27;r&#x27;</span>, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> wait(mode <span class="type">int</span>, isFile <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> pd.runtimeCtx == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;waiting for unsupported file type&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// runtime_pollWait是内部代码, 我们看不到了</span></span><br><span class="line">	res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line">	<span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了这么多, 其实根本就在一点, 语言封装的是<code>NONBLOCK</code>的io, 并netpoll提供的就是阻塞&#x2F;唤醒goroutine的机制, netpoll就是一个epoll, 只要把fd注册给netpoll, 我们就能在可以读写的时候唤醒协程。</p>
<p>作为go语言用户, 我们怎么利用netpoll? 那就是使用<code>poll.FD</code>了。如果我们想自己造一个tcp轮子, 完全可以用<code>poll.FD</code>自己写一套(不过没有意义), go的netpoll是基础设置, <code>net</code>是建立在它之上的, 我们是完全可以自己用<code>poll.FD</code>实现net包的。</p>
<h3 id="netpoll到底干了啥"><a href="#netpoll到底干了啥" class="headerlink" title="netpoll到底干了啥"></a>netpoll到底干了啥</h3><p>我们提到, 作为go语言用户, 如果想使用netpoll的阻塞&#x2F;唤醒机制, 只能通过poll.FD注册自己的文件描述符, 然后使用FD提供的接口:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Accept() (<span class="type">int</span>, syscall.Sockaddr, <span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Close() <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Dup() (<span class="type">int</span>, <span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Fchdir() <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Fchmod(mode <span class="type">uint32</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Fchown(uid <span class="type">int</span>, gid <span class="type">int</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Fstat(s *syscall.Stat_t) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Fsync() <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Ftruncate(size <span class="type">int64</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Init(net <span class="type">string</span>, pollable <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Pread(p []<span class="type">byte</span>, off <span class="type">int64</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Pwrite(p []<span class="type">byte</span>, off <span class="type">int64</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.RawControl(f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">uintptr</span>)</span></span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.RawRead(f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">uintptr</span>)</span></span> <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.RawWrite(f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">uintptr</span>)</span></span> <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.ReadDirent(buf []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.ReadFrom(p []<span class="type">byte</span>) (<span class="type">int</span>, syscall.Sockaddr, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.ReadFromInet4(p []<span class="type">byte</span>, from *syscall.SockaddrInet4) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.ReadFromInet6(p []<span class="type">byte</span>, from *syscall.SockaddrInet6) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.ReadMsg(p []<span class="type">byte</span>, oob []<span class="type">byte</span>, flags <span class="type">int</span>) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, syscall.Sockaddr, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.ReadMsgInet4(p []<span class="type">byte</span>, oob []<span class="type">byte</span>, flags <span class="type">int</span>, sa4 *syscall.SockaddrInet4) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.ReadMsgInet6(p []<span class="type">byte</span>, oob []<span class="type">byte</span>, flags <span class="type">int</span>, sa6 *syscall.SockaddrInet6) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetBlocking() <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetDeadline(t time.Time) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetReadDeadline(t time.Time) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetWriteDeadline(t time.Time) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetsockoptByte(level <span class="type">int</span>, name <span class="type">int</span>, arg <span class="type">byte</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetsockoptIPMreq(level <span class="type">int</span>, name <span class="type">int</span>, mreq *syscall.IPMreq) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetsockoptIPMreqn(level <span class="type">int</span>, name <span class="type">int</span>, mreq *syscall.IPMreqn) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetsockoptIPv6Mreq(level <span class="type">int</span>, name <span class="type">int</span>, mreq *syscall.IPv6Mreq) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetsockoptInet4Addr(level <span class="type">int</span>, name <span class="type">int</span>, arg [<span class="number">4</span>]<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetsockoptInt(level <span class="type">int</span>, name <span class="type">int</span>, arg <span class="type">int</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.SetsockoptLinger(level <span class="type">int</span>, name <span class="type">int</span>, l *syscall.Linger) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Shutdown(how <span class="type">int</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.WaitWrite() <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Write(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.WriteMsg(p []<span class="type">byte</span>, oob []<span class="type">byte</span>, sa syscall.Sockaddr) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.WriteMsgInet4(p []<span class="type">byte</span>, oob []<span class="type">byte</span>, sa *syscall.SockaddrInet4) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.WriteMsgInet6(p []<span class="type">byte</span>, oob []<span class="type">byte</span>, sa *syscall.SockaddrInet6) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.WriteOnce(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.WriteTo(p []<span class="type">byte</span>, sa syscall.Sockaddr) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.WriteToInet4(p []<span class="type">byte</span>, sa *syscall.SockaddrInet4) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.WriteToInet6(p []<span class="type">byte</span>, sa *syscall.SockaddrInet6) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*FD)</span></span>.Writev(v *[][]<span class="type">byte</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>提供给语言用户的就这些, 我们用起来特别简单, 但是实现呢? netpoll究竟干了啥? 哪个线程负责跑epoll?</p>
<p>我查阅了相关博客, 发现其实每一个m的调度代码都会有一个epoll。举个例子, 现在只有一个goroutine, 它正要<code>waitRead</code>, 把这个协程放入netpoll的等待队列, 然后进入调度代码, go发现, workout, 居然没有别的协程要调度了, 我也不能让cpu空转啊, 于是就会立马调用<code>netpoll(-1)</code>。一旦epoll发现文件描述符可读, 相关代码就会把g放入可执行队列, 调度器就又有g可以执行咯。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// netpoll 轮询网络并返回可运行的准备就绪的 goroutines 列表，传入的参数会决定他的行为</span></span><br><span class="line"><span class="comment">// - 参数 &lt; 0: 无限期阻塞等待文件就绪</span></span><br><span class="line"><span class="comment">// - 参数 == 0: 非阻塞轮询</span></span><br><span class="line"><span class="comment">// - 参数 &gt; 0: 阻塞定期轮询</span></span><br><span class="line"><span class="comment">// netpoll里面有个epoll_wait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> gList</span><br></pre></td></tr></table></figure>

<p>也就是说go调度器负责决定什么时候<code>epoll_wait</code>, 我是个小白, 对此完全不懂, 只能通过这个”cpu可能空转的例子”加深一下理解, 基本了解下是go的调度器在跑epoll就行了。</p>
<h3 id="有栈协程解决了什么问题-为什么不用epoll或者reactor了"><a href="#有栈协程解决了什么问题-为什么不用epoll或者reactor了" class="headerlink" title="有栈协程解决了什么问题? 为什么不用epoll或者reactor了?"></a>有栈协程解决了什么问题? 为什么不用epoll或者reactor了?</h3><p>一般而言, go的http框架做tcp读写都是写阻塞io而不是回调了(忽略字节的那个)。根本原因就是go通过语言层面的epoll解决了”线程是稀缺资源”这个问题, 赋予用户开N多执行流的能力。如果线程的切换的价格是低廉的, 就没人会用epoll。此外go封装了自己的epoll, 这种情况也没必要用epoll自己造了, 但是字节自己写了个reactor, 我不了解具体原因, 但是说法是可以减少切换的开销, 有不少的性能提升。</p>
<p>那么, 如果想用go实现reactor那种控制力很强的代码咋办? 就比如我想做一个tcp聊天室? 方法1: 使用go语言的reactor框架, 比较好的有字节的那个netpoll, 我之前考核写象棋用的是一个大佬写的gev(go当然也可以用syscall.Epoll的相关操作, 字节就用它自己造了一个reactor框架)。</p>
<p>方法2: 用goroutine+channel, 把消息发送给主的消息循环, 一个大的<code>for select</code>作为所有消息的接受者, 这样就能回归到原始的状态机了, 看看我考核的代码: 点击<a target="_blank" rel="noopener" href="https://github.com/markity/chess-frontend/blob/main/main.go">此处</a>。</p>
<p>处理单个的连接很有考究, 我用了读&#x2F;写两个goroutine处理一个线程, 然后用了channel做同步, 用<code>for select</code>这个大循环接收多种channel维持状态, 我感觉channel用好了控制力的效果和reactor是一样的, 其实都是写状态机嘛。</p>
<h3 id="无栈协程-为什么我注意到了它"><a href="#无栈协程-为什么我注意到了它" class="headerlink" title="无栈协程, 为什么我注意到了它?"></a>无栈协程, 为什么我注意到了它?</h3><p>在我尝试写这个分享的时候, 我其实还不知道无栈协程到底是什么, 但是基本上知道它能很大程度上被大佬封装成轮子, 然后提供给”调包侠”使用, 我们就能使用这个轮子做到单线程异步了, 并且写代码的难度还和go差不多。</p>
<p>下面是等疾风大佬做的一个轮子的echo server示例(等疾风做的工作就是使用c++最新提供的协程语法实现了一个调度器):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;co_context/net.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> co_context;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">session</span>(<span class="type">int</span> sockfd) &#123;</span><br><span class="line">    co_context::socket sock&#123;sockfd&#125;;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8192</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nr = <span class="keyword">co_await</span> sock.<span class="built_in">recv</span>(buf);</span><br><span class="line">        <span class="keyword">co_await</span> sock.<span class="built_in">send</span>(&#123;buf, (<span class="type">size_t</span>)nr&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;&gt; <span class="built_in">server</span>(<span class="type">const</span> <span class="type">uint16_t</span> port) &#123;</span><br><span class="line">    acceptor ac&#123;inet_address&#123;port&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sock; (sock = <span class="keyword">co_await</span> ac.<span class="built_in">accept</span>()) &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">		<span class="comment">// 就像go session(sock)</span></span><br><span class="line">		<span class="comment">// 		其实这也是one loop per thread模式, co_spawn通过线程局部变量</span></span><br><span class="line">		<span class="comment">//		拿到了io_context本体, 然后使用co_spawn注册了一个协程</span></span><br><span class="line">        <span class="built_in">co_spawn</span>(<span class="built_in">session</span>(sock));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context ctx;</span><br><span class="line">    ctx.<span class="built_in">co_spawn</span>(<span class="built_in">server</span>(<span class="number">1234</span>));</span><br><span class="line">    ctx.<span class="built_in">start</span>();</span><br><span class="line">    ctx.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ctx.start</code>是跑io线程, <code>ctx.join</code>会等待这个io线程结束。这是单线程异步哦, 利用一个单线程可以实现海量并发, 并且这个代码风格是同步代码哦。</p>
<p>可以看到其实和写阻塞代码没两样。据说无栈协程是一种语法糖, 只要库作者实现调度器, 就能把异步的代码改写为同步的代码, 不但兼顾性能并且代码风格优雅(没有回调)。</p>
<p>传统用reactor写的代码全是回调, 如果要发送一个dns查询, 可能会是这样的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="number">1.</span> <span class="built_in">send_dns_request</span>(target_name, func_dns_callback)</span><br><span class="line"><span class="number">2.</span> 在func_dns_callback继续你的动作</span><br></pre></td></tr></table></figure>

<p>但是用了协程, 代码可以变成这样:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">send_dns_request</span><span class="params">(target_name = ..., timeout = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 继续你的逻辑</span></span></span><br></pre></td></tr></table></figure>

<p>魔法在于, co_await后面跟一个协程函数, 它不会真正调用阻塞的<code>gethostname</code>这个阻塞操作系统的操作, 而是把执行流切换到调度器, 由调度器发送一个dns udp请求包, 然后调度器选择其它协程来跑。</p>
<p>调度器有个epoll, 每次调度前都会跑epoll, 把阻塞在某些io的协程重新恢复运行。一旦这个epoll收到了dns响应包, 就会将之前挂起的协程设置为runnable, 并设置好它的返回值。</p>
<p>弊端是协程代码里同样不能使用阻塞线程的操作或者复杂的计算操作, 它会阻塞调度器的调度, 调度器整个阻塞住了, 谈什么并发呢?</p>
<p>可以看出来这种协程还是和go的有很大的区别, 因为这种协程是”非抢占”的。如果要让调度器充分掌握控制权, 要么没有耗时任务(我指的是长时间耗时的计算任务或者阻塞的系统调用), 要么充分使用<code>co_yield</code>或者<code>await</code>把控制权交还给调度器(协程就是做io密集的工作的, 需要让调度器充分调度才能实现单线程大并发)。</p>
<p>如果要做线程耗时的任务, c++的协程还是得把任务打入工作线程, 然后工作线程再把计算结果打回到io线程(这里我提到的io线程是指跑协程调度器的那个线程)。这和reactor是一样的。不过这是个复杂的任务, 因为协程的各种同步设施和线程的是不一样的, 所以协程要和工作线程”交流”恐怕真的有点麻烦。</p>
<p>等疾风的轮子没有提供相关例子, 我也是个半调子, 但我想到一个简单(但低效)的方法能做到, 其实就是轮询:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">递交任务流程</span><br><span class="line">	1. 使用spin_lock, 锁住递送队列</span><br><span class="line">	2. 把任务打入任务</span><br><span class="line">	为什么用spin_lock? 因为我希望等待锁的时间尽可能少, 以免耽误调度器调度</span><br><span class="line"></span><br><span class="line">收回执行结果流程:</span><br><span class="line">	1. 使用spin_lock上锁, 锁住结果队列</span><br><span class="line">	2. 拿任务执行结果</span><br><span class="line">	3. 如果拿不到co_yield, 然后goto 1号步骤</span><br><span class="line"></span><br><span class="line">这样的思路其实就是疯狂轮询, 轮询不到结果就放弃执行权, 让其它协程先跑。</span><br></pre></td></tr></table></figure>

<p>要用起c++的协程写网络, 一个牛逼的调度器必不可少, 我上面用的调度器就是等疾风大佬做的, 据说他使用了<code>io_uring</code>, 性能爆表。要实现这样一个调度器, 需要实现各种阻塞原语, 比如像<code>sleep</code>这样的阻塞语句, 必须用其它非阻塞的法子做到, 然后在阻塞到期后恢复协程的调度。我目前没有实现这种调度器的经验。这位作者甚至实现了类似go的channel。</p>
<p>实现这个调度器, 要支持很多设施, 比如要实现协程锁, 要实现tcp&#x2F;udp socket, 要实现sleep, 要实现协程条件变量……我认为基本和内核做的工作差不多了。</p>
<h3 id="go的协程和上面的co-context的区别"><a href="#go的协程和上面的co-context的区别" class="headerlink" title="go的协程和上面的co_context的区别"></a>go的协程和上面的co_context的区别</h3><ol>
<li>go是抢占式的</li>
</ol>
<p>你肯定没有听说过在go语言里面开goroutine执行死循环会耽误调度器调度。事实上, 如果我们写<code>for&#123;&#125;</code>无限循环, 超过10ms没有切换新协程, go运行时就发信号强行抢占了。也就是说, 即使不调用netpoll的那些调度代码最后go也会有办法实现抢占的。</p>
<ol start="2">
<li>go的调度器跑在固定多的线程池上, 且在启动的时候就分配这些线程作为goroutine的”运行池”</li>
</ol>
<p>而上面c++的那个, 需要自己安排线程跑调度器</p>
<ol start="3">
<li>go的协程会在不同的地方陷入调度</li>
</ol>
<p>比如在消耗大量栈的函数之前插入陷入调度的代码。比如在运行系统调用之前(当然是使用go的syscall.XXX而不能调cgo)。比如执行”阻塞”操作的时候, 例如mutex, 信号量, 条件变量, netpoll的waitXXX都会陷入调度。长时间没有调度, 直接信号抢占, 就像操作系统的定时器抢占一样屌, 缺点是性能较拉, 因为信号抢占需要先陷入内核, 内核设置栈帧, 然后才能跑进抢占代码, 因此go语言有个编译选项可以指定是否关闭信号抢占(这通常会造成bug, 比如开和调度器一样多的协程序跑while(1), 将彻底堵死所有调度器)。</p>
<p>但是c++在哪里会被调度是程序员决定的, 比如co_await, co_yield, co_return, 程序员对自己在哪里陷入调度一清二楚。</p>
<h3 id="go什么时候会创建新的线程"><a href="#go什么时候会创建新的线程" class="headerlink" title="go什么时候会创建新的线程?"></a>go什么时候会创建新的线程?</h3><ol>
<li>使用系统调用</li>
</ol>
<p>即使不是慢系统调用(参考apue, 意思是可能长时间阻塞的系统调用, 比如<code>sleep</code>, <code>read</code>, <code>epoll_wait</code>, <code>select</code>), 有的系统调用依然会有不少的等待时间, 如果在go中调用syscallXXX, 必然新创建一个线程来做。</p>
<p>其实我之前提到的写文件, 虽然不是慢系统调用, 但是等待io的时间必然被浪费, 创建新线程代劳那些等待时间是必要的。</p>
<ol start="2">
<li>调用cgo之前</li>
</ol>
<p>想想如果调用cgo之前不创建线程代劳, cgo如果执行耗时操作就很耽误go调度器调度, 想想如果go使用8个线程跑调度器, 如果我开8个goroutine执行<code>while(1);</code>那该如何? 如果真的不创建新的线程代劳, 那么第九个正常的协程就永远没机会跑了。</p>
<p>需要知道的是go协程在跑线程的时候不会被调度(也不会被信号抢占), 回到go程序之后才能被正常调度。</p>
<h3 id="如何实现一个reactor框架"><a href="#如何实现一个reactor框架" class="headerlink" title="如何实现一个reactor框架?"></a>如何实现一个reactor框架?</h3><p>这点有很多细节, 推荐阅读陈硕的《Linux高性能并发服务器编程》, 其实虽然是c++书籍, 但是语言部分介绍很少, 基本在介绍思路, 比如双缓冲的高性能日志库, 比如比较不同的网络模式(例如one loop per thread, 其实就是reactor使用的模式, 此外才有一个线程一个连接的模式, 被他指出有性能问题)。</p>

    
  </div>
  <footer>
    
      
      
  <div class="tags">
    <a class="tags-none-link" href="/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/" rel="tag">知识分享</a>, <a class="tags-none-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" rel="tag">网络模型</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2024 <a href="/">Markity</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>浅玩一手: 使用mmap写framebuffer实现写屏, bmp图片格式概述, freetype2渲染文字 | Markity&#39;s Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="Markity">
  
  
    <meta name="description" content="unix中读写文件的基本函数在谈论mmap前, 先来回顾下linux如何使用系统调用读写文件。在c语言中如果要读写文件, 我们第一时间想到的就是open打开某个文件, 然后通过read&amp;#x2F;write对文件描述符读写。看下面的代码演示:">
  
  <meta name="description" content="unix中读写文件的基本函数在谈论mmap前, 先来回顾下linux如何使用系统调用读写文件。在c语言中如果要读写文件, 我们第一时间想到的就是open打开某个文件, 然后通过read&#x2F;write对文件描述符读写。看下面的代码演示:">
<meta property="og:type" content="article">
<meta property="og:title" content="浅玩一手: 使用mmap写framebuffer实现写屏, bmp图片格式概述, freetype2渲染文字">
<meta property="og:url" content="http://example.com/2023/05/08/fb/index.html">
<meta property="og:site_name" content="Markity&#39;s Notes">
<meta property="og:description" content="unix中读写文件的基本函数在谈论mmap前, 先来回顾下linux如何使用系统调用读写文件。在c语言中如果要读写文件, 我们第一时间想到的就是open打开某个文件, 然后通过read&#x2F;write对文件描述符读写。看下面的代码演示:">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blog-image-1257452121.cos.ap-chongqing.myqcloud.com/vt.gif">
<meta property="og:image" content="https://blog-image-1257452121.cos.ap-chongqing.myqcloud.com/fb-screen.jpg">
<meta property="og:image" content="https://blog-image-1257452121.cos.ap-chongqing.myqcloud.com/fb_render.bmp">
<meta property="article:published_time" content="2023-05-07T16:57:55.000Z">
<meta property="article:modified_time" content="2023-09-15T15:39:00.000Z">
<meta property="article:author" content="Markity">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="原理探究">
<meta property="article:tag" content="没用的冷知识">
<meta property="article:tag" content="太好玩了">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-image-1257452121.cos.ap-chongqing.myqcloud.com/vt.gif">
  
    <link rel="alternate" href="/atom.xml" title="Markity&#39;s Notes" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="https://blog-image-1257452121.cos.ap-chongqing.myqcloud.com/avatar.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Markity&#39;s Notes</a></h1>
    <p><a href="/"></a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2023/05/08/fb/">
  <time datetime="2023-05-07T16:57:55.000Z">
    2023-05-08
  </time>
</a>
    
    
  
    <h1 class="title">浅玩一手: 使用mmap写framebuffer实现写屏, bmp图片格式概述, freetype2渲染文字</h1>
  

  </header>
  
  <div class="entry">
    
      <h3 id="unix中读写文件的基本函数"><a href="#unix中读写文件的基本函数" class="headerlink" title="unix中读写文件的基本函数"></a>unix中读写文件的基本函数</h3><p>在谈论mmap前, 先来回顾下linux如何使用系统调用读写文件。在c语言中如果要读写文件, 我们第一时间想到的就是open打开某个文件, 然后通过read&#x2F;write对文件描述符读写。看下面的代码演示:</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./new_file&quot;</span>, O_RDWR|O_CREAT|O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to create new_file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *msg = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n = write(fd, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to write to new_file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解释下open的三个参数:</p>
<ul>
<li>参数1: 文件的路径</li>
<li>参数2: O_RDWR, 代表可读写, 打开一个文件必须包含O_RDONLY&#x2F;O_WRONLY&#x2F;O_RDWR三个之一。O_CREATE代表了如果文件不存在则创建文件。而O_EXCL必须与O_CREATE联合使用, 代表文件必须不存在, 再执行创建, 但如果文件存在则保存, 返回EEXIST错误。</li>
</ul>
<blockquote>
<p>如果仅仅使用O_CREATE的话, 文件存在时不会报错, 而是简单地打开。而O_CREATE|O_EXCL时文件存在则报错, 用这种组合的好处是能原子地判定文件不存在并创建新的文件, 这在某种场景下是很必要的。比如一个进程服务要求是“单例”的(也就是不允许同时运行两个相同的进程), 那么就能用O_CREATE|O_EXCL来创建一个标志文件。如果进程能成功创建这个文件, 那么它就有权运行。相反, 如果此文件已经存在, 那么open就会返回错误, 这个进程也就退出并打印: “进程已经在运行了, 请勿重复运行”的错误信息。</p>
</blockquote>
<ul>
<li>参数3: 代表如果创建了文件, 那么文件的权限是如何的。0600代表仅仅自己能读写, 而其他用户无权。0666则代表自己和其它用户都能读写。权限有三种: 读&#x2F;写&#x2F;执行, 不过多展开。这个很简单可以自行上网查阅。</li>
</ul>
<blockquote>
<p>值得注意的是, 如果这个文件已经存在, 而不是新创建出来的, 那么权限参数没有意义。参数3只在真正创建了文件的时候才赋予文件相应的权限设置。</p>
</blockquote>
<p>为什么我们不close fd?因为进程结束时, 内核会负责关闭所有打开的fd, 因此这里关不关都无所谓。</p>
<h3 id="如果用mmap读写文件"><a href="#如果用mmap读写文件" class="headerlink" title="如果用mmap读写文件?"></a>如果用mmap读写文件?</h3><p>mmap说白了就是能把文件描述符对应的文件内容映射到内存, 能像操作内存一样读写文件。下面进行一个演示(注意new_file里面有“hello world”文本):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./new_file&quot;</span>, O_RDWR, <span class="number">0660</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to create new_file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* mem = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to map memory&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mem[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    mem[<span class="number">1</span>] = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    mem[<span class="number">2</span>] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">    mem[<span class="number">3</span>] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">    mem[<span class="number">4</span>] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个程序后, 文件的内容变成了HELLO world。我们来说明一下参数的意义:</p>
<ul>
<li>参数1: 指定被映射到内存的哪个位置。这个参数一般为NULL代表让操作系统进行自动选择, 这是因为作为应用程序我们一般不知道哪块内存是空闲的, 因此要求内核帮我们将文件映射到合适的虚拟内存上去。</li>
<li>参数2: 映射的内存大小。</li>
<li>参数3: 可选的是PROT_READ(可读), PROT_WRITE(可写), PROT_EXEC(可动态加载代码, 然后跳过去执行, 动态库就用到了这个), PROT_NONE(不允许访问, 若访问, 那么触发缺页异常, 此时程序被SIGSEGV信号终止)。</li>
<li>参数4: 特殊的flag。有下面的flag:</li>
</ul>
<ol>
<li>MAP_SHARED: 对映射内存的写将会和文件内容同步, 会同步到底层的对象</li>
<li>MAP_PRIVATE: 相当于映射时只是进行一个复制, 并不会与底层对象产生同步。说实话, 这个我觉得意义不大。</li>
<li>MAP_ANONYMOUS: 不映射任何fd, 这是一种申请内存的特别方法, 特别适用于申请大内存。实际上malloc在申请大内存的时候就用了这个标志</li>
</ol>
<ul>
<li>参数5: 要映射的fd</li>
<li>参数6: 开始映射的位置。这里我们从文件开头就开始映射。</li>
</ul>
<blockquote>
<p>对于参数3值得注意的是, 如果我们指定了PROT_WRITE, 那么fd本身需要是可写的。如果fd本身不能读写, 那么PROT_READ和PROT_WRITE是无意义的。</p>
</blockquote>
<p>此时文件的大小仅仅只有“HELLO world”11个字节, 那么如果我们访问超过这个量怎么办呢? 我们可以看到, 虽然文件大小仅有11个字节, 我们却映射了4096个字节啊?答案很简单。此时, 内核会向程序发出SIGBUS信号终止这个程序。</p>
<p>那么有人就会疑问了, 这个mmap这么鸡肋, 用它读写文件不是脱裤子放屁吗? 答案是: 是的。如果你仅仅用它读写文件, 那么它就是不好用。然而mmap在跨进程的内存共享上有特别的用处。下面来列举一下它的应用场景:</p>
<ul>
<li>父进程的mmap将被子进程共享, 对于多进程的服务, 我们可以通过fork共享内存。做同步时, 以来mlock&#x2F;munlock系统调用, 可实现跨进程的进程锁。</li>
<li>我们之前提到的都是用mmap映射文件, 其实很多内核设备都能被映射。关于一个设备是否能被mmap映射, 这取决于这个设备有没有实现mmap的接口。很明显文件就实现了这个接口。此外我们之后讨论的framebuffer也实现了这个接口, 那么它也能被mmap映射。如果我们是驱动开发者, 我们做字符驱动设备时也可以考虑实现mmap的接口, 使得软件开发者用我们的设备文件更舒适。</li>
<li>mmap也有申请内存的特别功效, 我们之前提到的MAP_ANONYMOUS(匿名映射就是这样的), 之后来演示如何通过mmap申请内存。</li>
</ul>
<h3 id="mmap原理和懒加载"><a href="#mmap原理和懒加载" class="headerlink" title="mmap原理和懒加载"></a>mmap原理和懒加载</h3><p>mmap并不是把物理内存真的映射到虚拟内存上, 相反, 在mmap后它不作任何映射, 而是将这块内存区域记录在内核里面。事后此时如果进程要访问这块内存, 由于没有任何映射, 产生却页异常进入内核代码。然后内核负责分配物理内存做相关映射。</p>
<p>比如我们映射了一个文件的100k内容, 访问这块内存的第一个字节时, 将产生缺页错误。此时内核查表发现这块虚拟内存是有mmap映射的, 但是没有映射到任何物理内存, 此时内核就会分配4k的物理内存并把文件的前4k内容拷贝进去, 并将这块物理内存映射到相应的虚拟内存上。然后进程再次尝试访问这块内存, 就能访问到真正的物理内存了😃。</p>
<p>匿名映射的懒加载, 简而言之就是mmap如果匿名极大的内存, 这些内存不会被立刻分配物理内存, 而是在访问后, 触发缺页异常后内核再一点点分配。使用这个特性, 能很好地实现动态栈, 参见<a target="_blank" rel="noopener" href="https://markity.github.io/2023/02/17/d-stack/">我以前的博客</a>。这里有一个演示程序, 可以证明这一点:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 分配了2g, 然而我们读写1g内存</span></span><br><span class="line">    <span class="type">size_t</span> k = (<span class="type">size_t</span>)<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">char</span> *mem = mmap(<span class="literal">NULL</span>, k, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; k / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 换成char c = mem[i]; 来验证读也会触发内存分配</span></span><br><span class="line">        mem[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;完毕\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们的机器仅有8G内存却mmap匿名映射了80G, 此时mmap不会报错。当我们访问(不论是读还是写)这些内存的某个4k单元时, 由于页错误进入内核, 内核负责分配这个4k单元。电脑不会宕机。这就是懒加载: 在用的时候再加载。</p>
</blockquote>
<p>那么有人就好奇了, 如果已经映射好物理内存, 为啥我手动改变文件的内容, 程序读到的那块内存还会改变呢? 答案很简单, 在进程运行时其实不能察觉到文件内容的改变, 真正的改变其实是线程进入内核调度后, 内核负责相关同步和改变的。因此这中间其实有延时性, 直到进入内核调度之前, 此进程都不会直到文件是否已经发生了改变。</p>
<p>ok。现在我来臆想下MAP_PRIVATE究竟有啥用(但我的想法可能不对):</p>
<p>我们可以了解到MAP_PRIVATE不会把写入内存同步到底层对象中, 写入后只有自己知道, 别的进程一概不知。那么它就是在自娱自乐。当写入后, 在下一次进入内核调度后, 内核不会将对内存的写入同步到文件中, 只是把文件的变化同步给内存(但是如果我们写入了这块内存之后文件发生了改变, 文件的改变会覆盖我们的全部写入😡)。</p>
<p>既然少了把内存同步给文件的这个步骤, 那么就在在特定的场景下更快, 我能下面这个场景:</p>
<ul>
<li>文件永远不变, 我们的写入不需要反映给文件, 那么此时mmap就相当于把文件拷贝到内存, 并享有了我们上述提到了懒加载优势(访问的时候再加载一个4k的页)。</li>
</ul>
<blockquote>
<p>虽然我臆想了一下这个用途, 但是其实我还是不太自信, 到现在我还是觉得这个MAP_PRIVATE没太大的意义。</p>
</blockquote>
<h3 id="mmap匿名映射申请内存"><a href="#mmap匿名映射申请内存" class="headerlink" title="mmap匿名映射申请内存"></a>mmap匿名映射申请内存</h3><p>基本的demo:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* mem = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to map memory&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">        mem[i] = i%<span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里fd填的-1, 这是因为对匿名映射, fd没有任何意义, 它就不是用来映射fd的, 它不需要fd(因此我特地把它设置成没有意义的值)。它只是用来申请内存的。这里的MAP_PRITVATE属于没什么意义但必须填, 实际上填SHARD和PRIVATE都能工作(但我认为都没什么特别的意义)。</p>
<h3 id="mmap映射framebuffer来写屏"><a href="#mmap映射framebuffer来写屏" class="headerlink" title="mmap映射framebuffer来写屏"></a>mmap映射framebuffer来写屏</h3><p>芜湖, 来到正题。<code>/dev/fb0</code>是linux抽象出来的屏幕设备, 我们可以打开它然后mmap映射到内存上进行写屏。直接运行下面的代码就能玩。注意这个程序请打开tty2(因为默认的tty1是桌面, 我们需要切换到虚拟终端来运行这个程序)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ncurses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/vt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ncurses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    屏幕的坐标规定:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (0,0)------------------x轴</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    y轴</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开fb设备文件</span></span><br><span class="line">	<span class="type">int</span> framebuffer_fd = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (framebuffer_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">	    perror(<span class="string">&quot;failed to open framebuffer device&quot;</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Framebuffer device opened successfully.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取屏幕信息, var -&gt; variable, 是可修改的, 可变的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">vinfo</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (ioctl(framebuffer_fd, FBIOGET_VSCREENINFO, &amp;vinfo)) &#123;</span><br><span class="line">	    perror(<span class="string">&quot;failed to read variable information&quot;</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%dx%d, %dbpp\n&quot;</span>, vinfo.xres, vinfo.yres, vinfo.bits_per_pixel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个像素都会是4个字节表示它的颜色</span></span><br><span class="line">	<span class="keyword">if</span> (vinfo.bits_per_pixel != <span class="number">32</span>) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;not supported bits_per_pixel, it only supports 32 bit color&quot;</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 屏幕的大小=x像素数目*y像素数目</span></span><br><span class="line">	<span class="type">int</span> screen_size = vinfo.xres * vinfo.yres;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// framebuffer的设备实现了映射到内存的接口, 因此这里需要用mmap</span></span><br><span class="line">    <span class="comment">// 参数1: NULL, 起始位置由系统指定, 一般mmap都将它设置为NULL</span></span><br><span class="line">    <span class="comment">// 参数2: 映射的字节数目, 一个像素4字节(32bit)</span></span><br><span class="line">    <span class="comment">// 参数3: 指定读/写/执行权限, 这里只需要读写</span></span><br><span class="line">    <span class="comment">// 参数4: 这块内存是否独享, 如果是private, 那么它的写不会同步到文件, 然而文件改变会刷新这块内存</span></span><br><span class="line">    <span class="comment">//      而shared则同步到文件</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">char</span>* framebuffer_mem = (<span class="type">char</span> *)mmap(<span class="literal">NULL</span>, screen_size*vinfo.bits_per_pixel/<span class="number">8</span>, PROT_READ | PROT_WRITE, MAP_SHARED, framebuffer_fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (framebuffer_mem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    perror(<span class="string">&quot;failed to map framebuffer device to memory&quot;</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The framebuffer device was mapped to memory successfully.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Press Enter to show new screen:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(STDIN_FILENO, KDSETMODE, KD_GRAPHICS) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to set tty to graphics mode&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initscr();</span><br><span class="line">    raw();</span><br><span class="line">    noecho();</span><br><span class="line">    refresh();</span><br><span class="line">    keypad(stdscr, TRUE);</span><br><span class="line"></span><br><span class="line">    vinfo.activate |= FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(framebuffer_fd, FBIOPUT_VSCREENINFO, &amp;vinfo) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to set framebuffer mode&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = getch();</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; screen_size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                *(framebuffer_mem + i*<span class="number">4</span> + <span class="number">0</span>) = <span class="number">0xff</span>;</span><br><span class="line">                *(framebuffer_mem + i*<span class="number">4</span> + <span class="number">1</span>) = <span class="number">0x00</span>;</span><br><span class="line">                *(framebuffer_mem + i*<span class="number">4</span> + <span class="number">2</span>) = <span class="number">0x00</span>;</span><br><span class="line">                *(framebuffer_mem + i*<span class="number">4</span> + <span class="number">3</span>) = <span class="number">0x00</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *(framebuffer_mem + i*<span class="number">4</span> + <span class="number">0</span>) = <span class="number">0x00</span>;</span><br><span class="line">                *(framebuffer_mem + i*<span class="number">4</span> + <span class="number">1</span>) = <span class="number">0xff</span>;</span><br><span class="line">                *(framebuffer_mem + i*<span class="number">4</span> + <span class="number">2</span>) = <span class="number">0x00</span>;</span><br><span class="line">                *(framebuffer_mem + i*<span class="number">4</span> + <span class="number">3</span>) = <span class="number">0x00</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        usleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    end:</span><br><span class="line"></span><br><span class="line">	munmap((<span class="type">void</span>*)framebuffer_mem, screen_size*<span class="number">4</span>);</span><br><span class="line">	close(framebuffer_fd);</span><br><span class="line"></span><br><span class="line">    ioctl(STDIN_FILENO, KDSETMODE, KD_TEXT);</span><br><span class="line"></span><br><span class="line">    endwin();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行样例子(没有安装ncurses库自行安装):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc main.c -o main -lncurses</span><br><span class="line">&gt; ./main</span><br><span class="line">Framebuffer device opened successfully.</span><br><span class="line">2560x1080, 32bpp</span><br><span class="line">The framebuffer device was mapped to memory successfully.</span><br><span class="line">Press Enter to show new screen:</span><br><span class="line">(此时按Enter键绘制, 按其他键退出, 5s后程序结束)</span><br></pre></td></tr></table></figure>

<p>fb是framebuffer的缩写, 它是一个字符设备, 用来抽象屏幕的每个像素点来实现写屏。打开这个设备文件后, 我们需要第一时间用ioctl得到屏幕信息, 分辨率和支持的色彩bit数目。然后我们才能确定mmap多少字节才好。</p>
<p>每个1px单元都有4个字节(32比特)来描述它的色彩, 第一个字节是red, 第二个是grenn, 第三个是blue, 第四个是alpha表示透明度。</p>
<p>这里值得一提的设置是<code>vinfo.activate |= FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;</code>。默认下fb0的刷新很不积极, 通过设置这些位, 使得我们写入内存后内核及时读取内存更新屏幕。</p>
<p>此外用到了ncurses这个库。我用它的原因是我想简单地调用别人的轮子设置键盘映射, 我不希望用户在运行这个程序的时候按到ctrl+c导致无法正确还原到tty的KD_TEXT模式。ncurses的raw mode很好, 它会设置一些键盘映射, 我们可以通过ncurses的接口拿到用户的键盘输入。</p>
<blockquote>
<p>这里用到了ncurses库帮我们做键盘映射, 实际上可以自己做的, 然而我懒了, 也没研究过这些内容, 日后再研究。</p>
</blockquote>
<p>现在有了ncurses + framebuffer, 就可以自己控制屏幕和键盘了, 可以尝试做些小游戏玩玩。如果想要控制鼠标, 可以打开&#x2F;dev&#x2F;input里面的设备文件evnetn, 读取每个输入设备的相关数据。触摸板, 鼠标, 键盘, 甚至是笔记本的电源按键都创建了对应的event文件。</p>
<h3 id="VT-虚拟终端-图形模式-字符模式"><a href="#VT-虚拟终端-图形模式-字符模式" class="headerlink" title="VT(虚拟终端)?图形模式?字符模式?"></a>VT(虚拟终端)?图形模式?字符模式?</h3><p>我们暂不讨论安装桌面的linux环境, 假设现在电脑上装的只是无桌面的linux版本。登陆到终端后我们能用ALT + F1~F6切换到6个不同的虚拟终端进行工作。</p>
<p>现在我们将键盘+屏幕称为控制台(控制台只有一个), 那么就可以说控制台能够在多个虚拟终端间进行切换。</p>
<p>控制台的设备文件是console, 虚拟终端的设备文件就是tty, 目前拥有控制台的终端称为活动终端。ALT+F2其实就是切换了活动终端。从&#x2F;dev目录下我们只能找到一个console文件, 而却有63个tty文件。</p>
<p>linux最多支持63个tty, 我们可以自由切换到任何tty, 默认下linux只开启了6个, 我们可以更改这一配置, 修改<code>/etc/systemd/logind.conf</code>, 将<code>#NAutoVTs=6</code>变为<code>#NAutoVTs=63</code>就能拥有63个VT了。然而键盘只有F1-F12, 要切换到tty13-tty63, 我们需要用<code>chvt</code>这个命令切换。</p>
<p>我们可以理解为console利用framebuffer控制了屏幕, 而tty在某个时刻占有了console, 我们只能通过tty访问console。所以我们的键盘输入能够通过console传递给tty, tty也能够将相应的信息发给console供它显示给屏幕。它的架构就像下面:</p>
<p><img src="https://blog-image-1257452121.cos.ap-chongqing.myqcloud.com/vt.gif" alt="架构"></p>
<p>需要知道的是一般情况tty处于TEXT模式(文字模式)下, 如果我们想要接管整个屏幕, 自然不能再让tty绘制这个framebuffer。<code>ioctl(STDIN_FILENO, KDSETMODE, KD_TEXT);</code>可以进入图形模式, 这告知tty不要再绘制framebuffer, 让应用程序独占framebuffer, 这样tty和我们的应用程序就不会竞争写入framebuffer了, 这可以抑制光标闪烁。</p>
<p>然而在图形模式下无法切换活动终端, 假设我们在tty2下跑应用程序切换到图形模式, 只有在文字模式下<code>ALT+Fx</code>的组合键才起作用, 我想这应该是tty的特判。对于console发来的<code>ALT+Fx</code>键, 不会发给应用程序使用, 而是拦截住它然后切换活动终端。因此要在图形模式下切换活动终端, 相关逻辑需要我们自己写。</p>
<h3 id="将fb0导成图片"><a href="#将fb0导成图片" class="headerlink" title="将fb0导成图片"></a>将fb0导成图片</h3><p>假设已经安装好ffmpeg并设置相关环境变量, 执行指令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ffmpeg -f fbdev -i /dev/fb0 out.jpg</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-image-1257452121.cos.ap-chongqing.myqcloud.com/fb-screen.jpg" alt="展示图片"></p>
<blockquote>
<p>这里读者也许会好奇, 为何在桌面模式下(我的机子是kde桌面)显示的不是桌面的截图而是一个命令行界面。这与linux的显示架构有很大的关系, 我尚未研究😃。</p>
</blockquote>
<p>然后你就能看到fb0当前的显示状况了。用ffmpeg转图片很low, 下面我们提供一个程序生成bmp图片文件, 将fb0屏幕输出到文件里, 然后我们可以用图片预览软件观看。首先介绍下bmp文件格式。下面是它的字节结构:</p>
<table>
<thead>
<tr>
<th align="center">数据段名称</th>
<th align="center">是否可选</th>
<th align="center">大小(Byte)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bmp文件头</td>
<td align="center">必选</td>
<td align="center">14字节</td>
</tr>
<tr>
<td align="center">位图信息头</td>
<td align="center">必选</td>
<td align="center">40字节</td>
</tr>
<tr>
<td align="center">调色板信息</td>
<td align="center">可选</td>
<td align="center">由位图信息头里面的信息决定</td>
</tr>
<tr>
<td align="center">位图数据</td>
<td align="center">必选</td>
<td align="center">由图像的大小决定</td>
</tr>
</tbody></table>
<p>对于文件头, 我们用下面的结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitmapfileheader</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          bfType;             <span class="comment">// 0x4d42固定值, 标识文件类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>            bfSize;             <span class="comment">// 整个文件的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          bfReserved1;        <span class="comment">// 保留字段, 必须为0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          bfReserved2;        <span class="comment">// 保留字段, 必须为0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>            bfOffBits;          <span class="comment">// 从文件头到位图数据的偏移, 单位字节, 这里的偏移其实也可以说是位图数据相对整个文件起始位置的偏移</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">bitmapfileheader_t</span>;   <span class="comment">// 要求编译器不对此结构体进行内存对齐</span></span><br></pre></td></tr></table></figure>

<p>对于位图信息头, 用下面的结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitmapinfoheader</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    biSize;          <span class="comment">// 此结构体的大小 (14-17字节)</span></span><br><span class="line">    <span class="type">int</span>             biWidth;         <span class="comment">// 图像的宽  (18-21字节)</span></span><br><span class="line">    <span class="type">int</span>             biHeight;        <span class="comment">// 图像的高  (22-25字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  biPlanes;        <span class="comment">// 表示bmp图片的平面属，显然显示器只有一个平面，所以恒等于1 (26-27字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  biBitCount;      <span class="comment">// 一像素所占的位数   (28-29字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    biCompression;   <span class="comment">// 说明图象数据压缩的类型，0为不压缩。 (30-33字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    biSizeImage;     <span class="comment">// 像素数据所占大小, 这个值应该等于上面文件头结构中bfSize-bfOffBits (34-37字节)</span></span><br><span class="line">    <span class="type">int</span>             biXPelsPerMeter; <span class="comment">// 说明水平分辨率，用像素/米表示。一般为0 (38-41字节)</span></span><br><span class="line">    <span class="type">int</span>             biYPelsPerMeter; <span class="comment">// 说明垂直分辨率，用像素/米表示。一般为0 (42-45字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    biClrUsed;       <span class="comment">// 说明位图实际使用的调色板中的颜色索引数（设为0的话，则说明使用所有调色板项）。 (46-49字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    biClrImportant;  <span class="comment">// 说明对图象显示有重要影响的颜色索引的数目，如果是0，表示都重要。(50-53字节)</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">bitmapinfoheader_t</span>;</span><br></pre></td></tr></table></figure>

<p>讨论下各个字段的意义:</p>
<p>biBitCount常见的有1, 4, 8, 16, 24, 32。代表的意思是用多少个bit代表一个像素的颜色。其中24位是真色彩, 可以用红绿蓝三原色各8位表示现实中的所有颜色(RGB模式)。32位图像使用4字节保存颜色值，每一个字节代表一种颜色，除了原来的红、绿、蓝，还有Alpha通道，即透明色(RGBA模式)。这两种色彩是真色彩, 不需要用到调色板, 如果用这两种模式, 那就只包含bmp文件头, 位图信息头和位图数据了。</p>
<p>比如biBitCount为1, 那么此时只能用到两种颜色。那么到底是哪两种颜色呢? 是黑白还是红绿? 这就取决于调色板了。调色板信息紧接着图像信息头, 它就像一张映射表。四个字节R, G, B, A代表一个色彩。A为0则不设置透明通道。笔者的屏幕是32位真色彩的, 因此不需要调色板, 这个字段就是0了。</p>
<p>那么<code>biXPelsPerMeter</code>和<code>biYPelsPerMeter</code>是什么意思呢? 只是给显示器打印机的一个参考值, 我的理解是看软件如何理解它, 我认为设置为0即可。一般的软件显示图片是根据用户的屏幕大小和图片本身的分辨率放缩显示, 而不看这两个值。也就是说多数情况下它们没有意义。</p>
<p>biCompression代表压缩格式, .bmp是不经压缩的位图, 此外通过一些算法, 可以得到jpg和jpeg等格式的图片。</p>
<p>笔者不是很理解rgba中a(Alpha)的含义, 我从网上找到资料提到: Alpha指示每个像素的不透明程度，并允许使用Alpha合成将图像组合到其他像素上。这里我猜想对单一图层它没有什么意义, 但是与其它图层一起显示时, 就能发挥它的“透明度”的作用了。</p>
<p>上面talk了许多, 下面直接上代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitmapfileheader</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          bfType;             <span class="comment">// 0x4d42固定值, 标识文件类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>            bfSize;             <span class="comment">// 整个文件的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          bfReserved1;        <span class="comment">// 保留字段, 必须为0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          bfReserved2;        <span class="comment">// 保留字段, 必须为0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>            bfOffBits;          <span class="comment">// 从文件头到位图数据的偏移, 单位字节, 这里的偏移其实也可以说是位图数据相对整个文件起始位置的偏移</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">bitmapfileheader_t</span>;   <span class="comment">// 要求编译器不对此结构体进行内存对齐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitmapinfoheader</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    biSize;          <span class="comment">// 此结构体的大小 (14-17字节)</span></span><br><span class="line">    <span class="type">int</span>             biWidth;         <span class="comment">// 图像的宽  (18-21字节)</span></span><br><span class="line">    <span class="type">int</span>             biHeight;        <span class="comment">// 图像的高  (22-25字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  biPlanes;        <span class="comment">// 表示bmp图片的平面属，显然显示器只有一个平面，所以恒等于1 (26-27字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  biBitCount;      <span class="comment">// 一像素所占的位数   (28-29字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    biCompression;   <span class="comment">// 说明图象数据压缩的类型，0为不压缩。 (30-33字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    biSizeImage;     <span class="comment">// 像素数据所占大小, 这个值应该等于上面文件头结构中bfSize-bfOffBits (34-37字节)</span></span><br><span class="line">    <span class="type">int</span>             biXPelsPerMeter; <span class="comment">// 说明水平分辨率，用像素/米表示。一般为0 (38-41字节)</span></span><br><span class="line">    <span class="type">int</span>             biYPelsPerMeter; <span class="comment">// 说明垂直分辨率，用像素/米表示。一般为0 (42-45字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    biClrUsed;       <span class="comment">// 说明位图实际使用的调色板中的颜色索引数（设为0的话，则说明使用所有调色板项）。 (46-49字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    biClrImportant;  <span class="comment">// 说明对图象显示有重要影响的颜色索引的数目，如果是0，表示都重要。(50-53字节)</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">bitmapinfoheader_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;file_name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fbdev = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fbdev == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to open fb0 device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">vinfo</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (ioctl(fbdev, FBIOGET_VSCREENINFO, &amp;vinfo)) &#123;</span><br><span class="line">	    perror(<span class="string">&quot;failed to read variable information&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vinfo.bits_per_pixel != <span class="number">32</span>) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;not supported bits_per_pixel, it only supports 32 bit color&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* framebuffer_mem = <span class="built_in">malloc</span>(vinfo.xres*vinfo.yres*vinfo.bits_per_pixel/<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (framebuffer_mem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to malloc mem&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (read(fbdev, framebuffer_mem, vinfo.xres*vinfo.yres*vinfo.bits_per_pixel/<span class="number">8</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    perror(<span class="string">&quot;failed to read framebuffer device to memory&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, vinfo.xres, vinfo.yres, vinfo.bits_per_pixel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出文件由三部分组成</span></span><br><span class="line">    <span class="type">int</span> outputfileSize = <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>) + <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>) + vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">    <span class="type">char</span> *outputBytes = <span class="built_in">malloc</span>(outputfileSize);</span><br><span class="line">    <span class="keyword">if</span> (outputBytes == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to malloc mem&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;大小: %d\n&quot;</span>, outputfileSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写文件头</span></span><br><span class="line">    <span class="type">bitmapfileheader_t</span> fheader = &#123;&#125;;</span><br><span class="line">    fheader.bfType = <span class="number">0x4d42</span>;</span><br><span class="line">    fheader.bfSize = <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>) + <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>) + vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">    fheader.bfOffBits = <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>) + <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(outputBytes, &amp;fheader, <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写图像信息头</span></span><br><span class="line">    <span class="type">bitmapinfoheader_t</span> iheader = &#123;&#125;;</span><br><span class="line">    iheader.biBitCount = vinfo.bits_per_pixel;</span><br><span class="line">    iheader.biHeight = -vinfo.yres;</span><br><span class="line">    iheader.biWidth = vinfo.xres;</span><br><span class="line">    iheader.biPlanes = <span class="number">1</span>;</span><br><span class="line">    iheader.biSize = <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>);</span><br><span class="line">    iheader.biSizeImage = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(outputBytes+<span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>), &amp;iheader, <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝raw数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(outputBytes+<span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>)+<span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>), framebuffer_mem, vinfo.xres*vinfo.yres*vinfo.bits_per_pixel/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> outputFd = open(argv[<span class="number">1</span>], O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (outputFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to create file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(write(outputFd, outputBytes, outputfileSize) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to write to file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>值得注意的是, 代码中biHeight是负数, 这代表它是正向的位图。</p>
</blockquote>
<h3 id="tty支持中文显示"><a href="#tty支持中文显示" class="headerlink" title="tty支持中文显示?"></a>tty支持中文显示?</h3><p>相比爱折腾的人肯定想过让tty支持中文显示, 然后了解到了fbterm这个程序。它不但可以显示中文甚至还能在里面用fcitx输入法。即使在没有安装桌面的系统上, fbterm也能正常使用。</p>
<p>正如它的名字, fbterm正是用framebuffer来绘制的界面, 文字渲染则是使用的freetype进行渲染。</p>
<p>此外有大神写了内核补丁, 能够在console中显示cjk(中日韩)文字, 这很cool, 点击<a target="_blank" rel="noopener" href="https://linux.cn/article-949-1.html">此处</a>查看。</p>
<h3 id="调用freetype渲染文字"><a href="#调用freetype渲染文字" class="headerlink" title="调用freetype渲染文字"></a>调用freetype渲染文字</h3><p>很多时候我们低估了文字渲染的复杂性, 人类理所当然地再电脑上用输入法打字, 却不了解其代码层面的难度。在计算机上, 负责渲染文字的代码至少数以十万计。linux使用freetype2渲染文字, 有了别人的轮子, 我们能很简单地渲染出文字。在linux桌面环境下, gtk和qt都是调用freetype2的轮子进行文字渲染的。</p>
<p>绘图的基本步骤是通过freetype2库打开.ttf或.ttc后缀的字体文件, 根据编码找到对应的字形, 然后根据字形数据绘制文字。这里的字形指的是文字的图像。</p>
<p>ttf文件保存了一个face, 可以认为是一个字体。ttc文件则表示它拥有多个face, 即它有包含了多个字体。比如<code>/usr/share/fonts/noto-cjk/NotoSansCJK-Regular.ttc</code>拥有五个face。下面的程序打印了中日韩字体文件里面的所有face信息:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译:</span></span><br><span class="line"><span class="comment">// gcc xxx.c -lfreetype -I /usr/include/freetype2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ft2build.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> FT_FREETYPE_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FT_Library  library;</span><br><span class="line">FT_Face face;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FT_Error err = FT_Init_FreeType(&amp;library);</span><br><span class="line">    <span class="keyword">if</span> (err != FT_Err_Ok) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to init freetype2 library\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定打开的face索引为-1, 这样可以拿到num_faces, 这是官方提供的获取num_faces的方法。</span></span><br><span class="line">    err = FT_New_Face(library, <span class="string">&quot;/usr/share/fonts/noto-cjk/NotoSerifCJK-Regular.ttc&quot;</span>, <span class="number">-1</span>, &amp;face);</span><br><span class="line">    <span class="keyword">if</span> (err != FT_Err_Ok) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to new freetype2 face\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; face-&gt;num_faces; i ++) &#123;</span><br><span class="line">        err = FT_New_Face(library, <span class="string">&quot;/usr/share/fonts/noto-cjk/NotoSerifCJK-Regular.ttc&quot;</span>, i, &amp;face);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, face-&gt;family_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">Noto Serif CJK JP 65535</span></span><br><span class="line"><span class="comment">Noto Serif CJK KR 65535</span></span><br><span class="line"><span class="comment">Noto Serif CJK SC 65535</span></span><br><span class="line"><span class="comment">Noto Serif CJK TC 65535</span></span><br><span class="line"><span class="comment">Noto Serif CJK HK 65535</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到cjk中日韩的ttc字体文件里面有五组字符, jp日本, kr韩国, sc简体中文, tc繁体中文, hk香港。</p>
<blockquote>
<p>一个字体文件不一定包含所有unicode字符的字形, 完整的字形渲染往往需要查找很多ttf&#x2F;ttc文件。比如有专门的emoji字体文件, 有的字体文件只有中文, 有的只有字母数字和ascii符号。在linux中使用fontconfig工具可以找到支持某个码点的字体, qt的字体渲染就是使用的freetype2+fontconfig。</p>
</blockquote>
<p>接下来我们来谈一谈矢量字体, 我们知道矢量字体的特点就是它在高分辨率下依旧丝滑。而点阵字体的缺点就是如果放大缩小, 就会出现模糊锯齿的现象。矢量字体的关键点就在它用存储了字体关键点, 利用数学曲线连接关键点, 然后填充闭合曲线的方法动态绘制。</p>
<p>然而需要知道的是, 虽然动态绘制的方式很好, 但是在小尺寸比如12px * 12px上的效果很不好(因为点太少了, 没法拟合出好的效果), 所以为了这种变态的需求, 对于字体的某些特定尺寸保存了自行的点阵图。我们可以说ttf文件不仅有矢量图, 为了极致的美观还会在使用特定尺寸时切换到点阵图。这些点阵图都是字体工作人员一点一点地做出来的,太幸苦了😢。</p>
<blockquote>
<p>从&#x2F;usr&#x2F;share&#x2F;fonts&#x2F;noto的文件名来看, 可以看到对于某个字体它拥有多种形式, 比如NotoSerifYezidi-Bold.ttf, NotoSerifYezidi-Regular.ttf。如果我们想让字体的样式是粗体的, 那么可以用到Bold后缀的字体文件。很多字体没有设计斜体字体文件, 比如浏览器里面显示斜体的emoji, 但是软件依然可以显示出斜体的emoji字体, 这是因为矢量图是用线绘制的, 可以通过transform旋转来影响线的绘制, 这样就能绘制出假斜体。</p>
</blockquote>
<p>ttf文件存储了很多字的字形, 需要通过编码找到对应的字形索引, 每个face都可以支持多个编码, 打开face之后默认就是unicode编码, 一般unicode就是最优的了, 2023年就不要再用其他编码了。下面我们使用代码拿到一个字符的bmp数据并写入文件:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitmapfileheader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> bfType;                    <span class="comment">// 0x4d42固定值, 标识文件类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bfSize;                      <span class="comment">// 整个文件的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> bfReserved1;               <span class="comment">// 保留字段, 必须为0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> bfReserved2;               <span class="comment">// 保留字段, 必须为0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bfOffBits;                   <span class="comment">// 从文件头到位图数据的偏移, 单位字节, 这里的偏移其实也可以说是位图数据相对整个文件起始位置的偏移</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">bitmapfileheader_t</span>; <span class="comment">// 要求编译器不对此结构体进行内存对齐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitmapinfoheader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> biSize;         <span class="comment">// 此结构体的大小 (14-17字节)</span></span><br><span class="line">    <span class="type">int</span> biWidth;                 <span class="comment">// 图像的宽  (18-21字节)</span></span><br><span class="line">    <span class="type">int</span> biHeight;                <span class="comment">// 图像的高  (22-25字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> biPlanes;     <span class="comment">// 表示bmp图片的平面属，显然显示器只有一个平面，所以恒等于1 (26-27字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> biBitCount;   <span class="comment">// 一像素所占的位数   (28-29字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> biCompression;  <span class="comment">// 说明图象数据压缩的类型，0为不压缩。 (30-33字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> biSizeImage;    <span class="comment">// 像素数据所占大小, 这个值应该等于上面文件头结构中bfSize-bfOffBits (34-37字节)</span></span><br><span class="line">    <span class="type">int</span> biXPelsPerMeter;         <span class="comment">// 说明水平分辨率，用像素/米表示。一般为0 (38-41字节)</span></span><br><span class="line">    <span class="type">int</span> biYPelsPerMeter;         <span class="comment">// 说明垂直分辨率，用像素/米表示。一般为0 (42-45字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> biClrUsed;      <span class="comment">// 说明位图实际使用的调色板中的颜色索引数（设为0的话，则说明使用所有调色板项）。 (46-49字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> biClrImportant; <span class="comment">// 说明对图象显示有重要影响的颜色索引的数目，如果是0，表示都重要。(50-53字节)</span></span><br><span class="line">&#125; __attribute__((packed)) <span class="type">bitmapinfoheader_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ft2build.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freetype2/freetype/ftcolor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> FT_FREETYPE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> FT_GLYPH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> FT_OUTLINE_H</span></span><br><span class="line"></span><br><span class="line">FT_Library library;</span><br><span class="line">FT_Face face;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FT_Error error = FT_Init_FreeType(&amp;library);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to FT_Init_FreeType\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> major, minor;</span><br><span class="line">    FT_Library_Version(library, &amp;major, &amp;minor, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;version: %d.%d\n&quot;</span>, major, minor);</span><br><span class="line"></span><br><span class="line">    error = FT_New_Face(library, <span class="string">&quot;/usr/share/fonts/noto-cjk/NotoSerifCJK-Regular.ttc&quot;</span>, <span class="number">0</span>, &amp;face);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to FT_New_Face\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="number">64</span>;</span><br><span class="line">    error = FT_Set_Pixel_Sizes(face, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;font size %d not supported\n&quot;</span>, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FT_UInt glyphIdx = FT_Get_Char_Index(face, <span class="string">L&#x27;我&#x27;</span>);</span><br><span class="line">    error = FT_Load_Glyph(face, glyphIdx, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (glyphIdx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;glyph not found\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;glyph index: %d\n&quot;</span>, glyphIdx);</span><br><span class="line"></span><br><span class="line">    error = FT_Load_Glyph(face, glyphIdx, FT_LOAD_COLOR|FT_LOAD_DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to load glyph\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FT_Glyph glyph;</span><br><span class="line">    FT_Get_Glyph(face-&gt;glyph, &amp;glyph);</span><br><span class="line">    FT_Glyph_To_Bitmap(&amp;glyph, FT_RENDER_MODE_NORMAL, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    FT_BitmapGlyph glyphBitmap = (FT_BitmapGlyph)glyph;</span><br><span class="line"></span><br><span class="line">    FT_Bitmap bitmap = glyphBitmap-&gt;bitmap;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;height(px): %d width(px): %d pitch: %d\n&quot;</span>, bitmap.rows, bitmap.width, bitmap.pitch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//      ---</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bufferSize = <span class="number">4</span> * bitmap.rows * bitmap.width;</span><br><span class="line">    <span class="type">int</span> outputfileSize = <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>) + <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>) + bufferSize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *outputBytes = <span class="built_in">malloc</span>(outputfileSize);</span><br><span class="line">    <span class="keyword">if</span> (outputBytes == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to malloc mem&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file size: %d\n&quot;</span>, outputfileSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;image buffer size: %d\n&quot;</span>, bufferSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写文件头</span></span><br><span class="line">    <span class="type">bitmapfileheader_t</span> fheader = &#123;&#125;;</span><br><span class="line">    fheader.bfType = <span class="number">0x4d42</span>;</span><br><span class="line">    fheader.bfSize = outputfileSize;</span><br><span class="line">    fheader.bfOffBits = <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>) + <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(outputBytes, &amp;fheader, <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写图像信息头</span></span><br><span class="line">    <span class="type">bitmapinfoheader_t</span> iheader = &#123;&#125;;</span><br><span class="line">    iheader.biBitCount = <span class="number">32</span>;</span><br><span class="line">    iheader.biHeight = -bitmap.rows;</span><br><span class="line">    iheader.biWidth = bitmap.width;</span><br><span class="line">    iheader.biPlanes = <span class="number">1</span>;</span><br><span class="line">    iheader.biSize = <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>);</span><br><span class="line">    iheader.biSizeImage = bufferSize;</span><br><span class="line">    <span class="built_in">memcpy</span>(outputBytes + <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>), &amp;iheader, <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将8bit灰度图片转换为rgb格式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; bitmap.rows; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; bitmap.width; x++) &#123;</span><br><span class="line">            <span class="type">unsigned</span> grayScale = bitmap.buffer[y * bitmap.pitch + x];</span><br><span class="line">            <span class="keyword">if</span> (grayScale) &#123;</span><br><span class="line">                *((outputBytes + <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>) + <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>) + y * bitmap.width*<span class="number">4</span> + x*<span class="number">4</span> + <span class="number">0</span>)) = grayScale;</span><br><span class="line">                *((outputBytes + <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>) + <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>) + y * bitmap.width*<span class="number">4</span> + x*<span class="number">4</span> + <span class="number">1</span>)) = grayScale;</span><br><span class="line">                *((outputBytes + <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>) + <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>) + y * bitmap.width*<span class="number">4</span> + x*<span class="number">4</span> + <span class="number">2</span>)) = grayScale;</span><br><span class="line">                *((outputBytes + <span class="keyword">sizeof</span>(<span class="type">bitmapfileheader_t</span>) + <span class="keyword">sizeof</span>(<span class="type">bitmapinfoheader_t</span>) + y * bitmap.width*<span class="number">4</span> + x*<span class="number">4</span> + <span class="number">3</span>)) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> outputFd = open(<span class="string">&quot;ft2_output.bmp&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (outputFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to create file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(outputFd, outputBytes, outputfileSize) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;failed to write to file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">version: 2.13</span></span><br><span class="line"><span class="comment">glyph index: 18528</span></span><br><span class="line"><span class="comment">height(px): 61 width(px): 60 pitch: 60</span></span><br><span class="line"><span class="comment">file size: 14694</span></span><br><span class="line"><span class="comment">image buffer size: 14640</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>渲染出的图片:</p>
<p><img src="https://blog-image-1257452121.cos.ap-chongqing.myqcloud.com/fb_render.bmp" alt="渲染结果"></p>
<p>值得注意的是, 不同于24字节代表一个像素的rgb格式, 我们程序中拿到的glyph-&gt;bitmap每一个像素只有一个字节代表色彩。它是一张灰度图, 要还原到RGB, 直接按程序中写法处理即可。关于freetype2的诸多机制, 我无法过多赘述, 请参考<a target="_blank" rel="noopener" href="https://kevinboone.me/fbtextdemo.html">这篇博文</a>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://linux.cn/article-949-1.html">cjktty</a></li>
<li><a target="_blank" rel="noopener" href="https://kevinboone.me/fbtextdemo.html">freetype2简要教程</a></li>
</ul>

    
  </div>
  <footer>
    
      
      
  <div class="tags">
    <a class="tags-none-link" href="/tags/linux/" rel="tag">linux</a>, <a class="tags-none-link" href="/tags/%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" rel="tag">原理探究</a>, <a class="tags-none-link" href="/tags/%E5%A4%AA%E5%A5%BD%E7%8E%A9%E4%BA%86/" rel="tag">太好玩了</a>, <a class="tags-none-link" href="/tags/%E6%B2%A1%E7%94%A8%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/" rel="tag">没用的冷知识</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2024 <a href="/">Markity</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>